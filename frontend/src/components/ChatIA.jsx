// ChatIA.js - VERSION COMPL√àTEMENT CORRIG√âE - TOUTES ERREURS R√âSOLUES
import React, { useState, useEffect, useRef } from 'react';

const ChatIA = ({ 
  student, 
  apiUrl, 
  documentContext = '', 
  allDocuments = [],
  selectedDocumentId = null,  // üîß CORRECTION 1: Prop manquante ajout√©e
  chatHistory = [],
  setChatHistory,
  chatTokensUsed = 0,
  setChatTokensUsed,
  onStatsUpdate
}) => {
  const [messages, setMessages] = useState(chatHistory || []);
  const [inputMessage, setInputMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [conversationCount, setConversationCount] = useState(0);
  const [totalTokens, setTotalTokens] = useState(chatTokensUsed || 0);
  const [welcomeMessageSent, setWelcomeMessageSent] = useState(false);
  const [learningProfile, setLearningProfile] = useState(null);
  
  // üéØ √âTATS R√âVOLUTIONNAIRES
  const [chatMode, setChatMode] = useState('normal');
  const [currentStep, setCurrentStep] = useState(1);
  const [totalSteps, setTotalSteps] = useState(4);
  const [isAudioMode, setIsAudioMode] = useState(false);
  const [isDarkMode, setIsDarkMode] = useState(false);
  
  // üîß CORRECTION 2: GESTION TOKENS CORRIG√âE
  const [tokenUsage, setTokenUsage] = useState({ 
    used_today: chatTokensUsed || 0, 
    remaining: 95000 - (chatTokensUsed || 0),
    total_conversations: 0,
    last_updated: Date.now()
  });
  
  const [connectionStatus, setConnectionStatus] = useState('online');
  const [isRecording, setIsRecording] = useState(false);
  const [recognition, setRecognition] = useState(null);
  
  const messagesEndRef = useRef(null);
  const inputRef = useRef(null);

  // ‚úÖ R√©cup√©ration s√©curis√©e du pr√©nom
  const prenomEleve = student?.nom?.split(' ')[0] || student?.name?.split(' ')[0] || '√âl√®ve';
  const classeEleve = student?.classe || student?.class_level || 'votre classe';

  // üîß CORRECTION 3: FONCTION MISE √Ä JOUR TOKENS SYNCHRONIS√âE
  const updateTokenUsage = (newTokens, totalTokens = null) => {
    const updatedTokens = totalTokens !== null ? totalTokens : tokenUsage.used_today + newTokens;
    
    setTokenUsage(prev => {
      const updated = {
        ...prev,
        used_today: updatedTokens,
        remaining: 95000 - updatedTokens,
        total_conversations: prev.total_conversations + 1,
        last_updated: Date.now()
      };
      
      console.log('üîã Tokens mis √† jour:', updated);
      return updated;
    });

    // üîß CORRECTION 4: Synchronisation avec parent
    if (setChatTokensUsed) {
      setChatTokensUsed(updatedTokens);
    }
  };

  // üîß CORRECTION 5: Synchronisation historique messages
  useEffect(() => {
    if (setChatHistory && messages.length > 0) {
      setChatHistory(messages);
    }
  }, [messages, setChatHistory]);

  // üîß CORRECTION 6: Synchronisation tokens depuis parent
  useEffect(() => {
    if (chatTokensUsed !== tokenUsage.used_today) {
      setTokenUsage(prev => ({
        ...prev,
        used_today: chatTokensUsed,
        remaining: 95000 - chatTokensUsed
      }));
    }
  }, [chatTokensUsed]);

  // üé§ INITIALISATION RECONNAISSANCE VOCALE
  useEffect(() => {
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      const recognitionInstance = new SpeechRecognition();
      
      recognitionInstance.continuous = false;
      recognitionInstance.interimResults = false;
      recognitionInstance.lang = 'fr-FR';
      
      recognitionInstance.onstart = () => {
        console.log('üé§ Reconnaissance vocale d√©marr√©e');
        setIsRecording(true);
      };
      
      recognitionInstance.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        console.log('üé§ Texte reconnu:', transcript);
        setInputMessage(transcript);
        setIsRecording(false);
      };
      
      recognitionInstance.onerror = (event) => {
        console.error('‚ùå Erreur reconnaissance vocale:', event.error);
        setIsRecording(false);
      };
      
      recognitionInstance.onend = () => {
        console.log('üé§ Reconnaissance vocale termin√©e');
        setIsRecording(false);
      };
      
      setRecognition(recognitionInstance);
    }
  }, []);

  // üîä FONCTION SYNTH√àSE VOCALE AM√âLIOR√âE
  const speakResponse = (text) => {
    if ('speechSynthesis' in window) {
      speechSynthesis.cancel();
      
      const cleanText = text
        .replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '')
        .replace(/üìä|üîÅ|‚úÖ|üéØ|üí¨|ü§ñ/g, '')
        .replace(/√âtape \d+\/\d+/g, '')
        .trim();
      
      const utterance = new SpeechSynthesisUtterance(cleanText);
      utterance.lang = 'fr-FR';
      utterance.rate = 0.9;
      utterance.pitch = 1.0;
      utterance.volume = 0.8;
      
      const voices = speechSynthesis.getVoices();
      const frenchVoice = voices.find(voice => voice.lang.startsWith('fr'));
      if (frenchVoice) {
        utterance.voice = frenchVoice;
      }
      
      utterance.onstart = () => console.log('üîä Synth√®se vocale d√©marr√©e');
      utterance.onend = () => console.log('üîä Synth√®se vocale termin√©e');
      utterance.onerror = (event) => console.error('‚ùå Erreur synth√®se vocale:', event.error);
      
      speechSynthesis.speak(utterance);
    } else {
      console.warn('‚ö†Ô∏è Synth√®se vocale non support√©e');
    }
  };

  // üé§ FONCTION D√âMARRAGE RECONNAISSANCE VOCALE
  const startVoiceRecognition = () => {
    if (recognition && !isRecording) {
      try {
        recognition.start();
        console.log('üé§ D√©marrage reconnaissance vocale...');
      } catch (error) {
        console.error('‚ùå Erreur d√©marrage reconnaissance:', error);
        setIsRecording(false);
      }
    } else if (!recognition) {
      console.warn('‚ö†Ô∏è Reconnaissance vocale non support√©e');
      alert('üé§ Votre navigateur ne supporte pas la reconnaissance vocale. Utilisez Chrome ou Edge.');
    } else {
      console.log('üé§ Reconnaissance vocale d√©j√† en cours...');
    }
  };

  // Suggestions intelligentes selon le profil
  const getSuggestions = () => {
    const baseSuggestions = [
      "Explique-moi ce document en d√©tail",
      "Quels sont les points cl√©s √† retenir ?",
      "Aide-moi avec cet exercice",
      "Comment r√©viser efficacement cette le√ßon ?"
    ];

    if (learningProfile?.style === 'interactif') {
      return [
        "Pose-moi des questions sur ce chapitre",
        "Cr√©ons un quiz ensemble",
        "V√©rifie ma compr√©hension",
        "D√©battons de ce sujet"
      ];
    } else if (learningProfile?.style === 'pratique') {
      return [
        "Montrons avec des exemples concrets",
        "Faisons des exercices pratiques",
        "Applications dans la vie r√©elle",
        "Exercices √©tape par √©tape"
      ];
    }

    return baseSuggestions;
  };

  // üîß CORRECTION 7: MESSAGE D'ACCUEIL CORRIG√â
  const triggerWelcomeMessage = async () => {
    if (welcomeMessageSent) return;
    
    console.log('üéâ D√©clenchement message d\'accueil...');
    
    try {
      setIsLoading(true);
      setConnectionStatus('connecting');
      
      // üîß R√âCUP√âRATION DOCUMENT AVEC GESTION ERREUR
      let currentDocument = null;
      let contextToSend = '';
      
      try {
        if (selectedDocumentId && allDocuments.length > 0) {
          currentDocument = allDocuments.find(doc => doc.id === selectedDocumentId);
        }
        
        if (!currentDocument && allDocuments.length > 0) {
          currentDocument = allDocuments[0];
        }
        
        contextToSend = currentDocument?.texte_extrait || documentContext || '';
      } catch (docError) {
        console.warn('‚ö†Ô∏è Erreur r√©cup√©ration document:', docError.message);
        contextToSend = documentContext || '';
      }
      
      console.log('üìÑ Contexte pour accueil:', {
        document_found: !!currentDocument,
        document_name: currentDocument?.nom_original || 'Aucun',
        context_length: contextToSend.length
      });
      
      // ‚úÖ APPEL SIMPLIFI√â √Ä L'API
      const response = await fetch(`${apiUrl}/api/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: 'connexion',
          user_id: student.id,
          document_context: contextToSend,
          is_welcome: true,
          mode: 'normal'
        }),
      });

      console.log('üì° R√©ponse API accueil:', response.status, response.ok);
      
      if (!response.ok) {
        throw new Error(`Erreur serveur: ${response.status}`);
      }
      
      const data = await response.json();
      console.log('üìä Donn√©es accueil re√ßues:', {
        success: data.success,
        has_context: data.has_context,
        document_name: data.document_name
      });

      if (data.success !== false) {
        const welcomeMessage = {
          id: Date.now(),
          type: 'ai',
          content: data.response,
          timestamp: data.timestamp,
          tokens: data.tokens_used || 0,
          model: data.model,
          hasContext: data.has_context,
          isWelcome: true,
          documentUsed: data.document_name
        };

        setMessages([welcomeMessage]);
        setWelcomeMessageSent(true);
        setConnectionStatus('online');

        if (data.tokens_used) {
          updateTokenUsage(data.tokens_used);
        }
        
        console.log(`‚úÖ Message d'accueil OK avec document: "${data.document_name}"`);
        
      } else {
        throw new Error(data.error || 'Erreur r√©ponse API');
      }
      
    } catch (error) {
      console.error('‚ùå Erreur message d\'accueil:', error.message);
      setConnectionStatus('offline');
      
      // FALLBACK LOCAL ROBUSTE
      const fallbackMessage = {
        id: Date.now(),
        type: 'ai',
        content: `Salut ${prenomEleve} ! ü§ñ

Je suis √âtudIA, ton tuteur IA r√©volutionnaire !

${allDocuments.length > 0 ? 
  `üìÑ Document d√©tect√© : "${allDocuments[0].nom_original}"` : 
  'üìÑ Aucun document - Upload-en un pour commencer !'}

üéØ Mode hors ligne temporaire activ√©.
Pose-moi tes questions, je ferai de mon mieux ! ‚ú®

üí° Recharge la page pour reconnecter √† √âtudIA !`,
        timestamp: new Date().toISOString(),
        tokens: 0,
        isWelcome: true,
        isOffline: true
      };

      setMessages([fallbackMessage]);
      setWelcomeMessageSent(true);
      
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (student?.id && !welcomeMessageSent) {
      setTimeout(triggerWelcomeMessage, 500);
    }
  }, [student, welcomeMessageSent]);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  useEffect(() => {
    if (!isLoading && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isLoading]);

  // üîß CORRECTION 8: FONCTION ENVOI MESSAGE COMPL√àTEMENT CORRIG√âE
  const handleSendMessage = async (messageText = inputMessage, mode = chatMode) => {
    if (!messageText.trim() || isLoading) return;

    const userMessage = {
      id: Date.now(),
      type: 'user',
      content: messageText.trim(),
      timestamp: new Date().toISOString(),
      tokens: 0,
      mode: mode
    };

    setMessages(prev => [...prev, userMessage]);
    setInputMessage('');
    setIsLoading(true);

    try {
      // üîß CORRECTION 9: GESTION DOCUMENT ACTIVE S√âCURIS√âE
      let activeDocument = null;
      let finalDocumentContext = '';
      let hasValidContext = false;

      try {
        // Strat√©gie 1: Document s√©lectionn√© sp√©cifiquement
        if (selectedDocumentId && allDocuments.length > 0) {
          activeDocument = allDocuments.find(doc => doc.id === selectedDocumentId);
          console.log('üéØ Document s√©lectionn√© trouv√©:', activeDocument?.nom_original);
        }
        
        // Strat√©gie 2: Premier document disponible
        if (!activeDocument && allDocuments.length > 0) {
          activeDocument = allDocuments[0];
          console.log('üéØ Premier document utilis√©:', activeDocument?.nom_original);
        }
        
        // Strat√©gie 3: Contexte fourni directement
        finalDocumentContext = activeDocument?.texte_extrait || documentContext || '';
        hasValidContext = finalDocumentContext && finalDocumentContext.length > 50;
        
        console.log('üì§ Contexte document final:', {
          active_document: activeDocument?.nom_original || 'Aucun',
          context_length: finalDocumentContext.length,
          has_valid_context: hasValidContext,
          mode: mode,
          message_preview: messageText.substring(0, 50) + '...'
        });
        
      } catch (contextError) {
        console.warn('‚ö†Ô∏è Erreur r√©cup√©ration contexte:', contextError.message);
        finalDocumentContext = documentContext || '';
        hasValidContext = false;
      }

      // üîß PAYLOAD ENRICHI AVEC CONTEXTE GARANTI
      const payload = {
        message: messageText.trim(),
        user_id: student.id,
        document_context: finalDocumentContext,
        mode: mode,
        selected_document_id: selectedDocumentId || null,
        document_name: activeDocument?.nom_original || '',
        has_document: hasValidContext
      };

      // Ajouter info √©tapes si mode step_by_step
      if (mode === 'step_by_step') {
        payload.step_info = {
          current_step: currentStep,
          total_steps: totalSteps
        };
      }

      console.log('üì° Envoi vers API:', {
        url: `${apiUrl}/api/chat`,
        payload_keys: Object.keys(payload),
        user_id: payload.user_id,
        has_context: !!payload.document_context
      });

      const response = await fetch(`${apiUrl}/api/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      console.log('üì° R√©ponse API chat:', response.status, response.ok);

      if (!response.ok) {
        throw new Error(`Erreur HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      console.log('üìä Donn√©es chat re√ßues:', {
        success: data.success,
        response_length: data.response?.length || 0,
        tokens_used: data.tokens_used,
        has_context: data.has_context
      });

      if (data.success !== false) {
        const aiMessage = {
          id: Date.now() + 1,
          type: 'ai',
          content: data.response,
          timestamp: data.timestamp,
          tokens: data.tokens_used || 0,
          model: data.model,
          hasContext: data.has_context || hasValidContext,
          mode: mode,
          nextStep: data.next_step,
          documentUsed: data.document_name || activeDocument?.nom_original,
          contextLength: data.context_length || finalDocumentContext.length,
          responseValidated: true
        };

        setMessages(prev => [...prev, aiMessage]);
        setConversationCount(prev => prev + 1);
        setTotalTokens(prev => prev + (data.tokens_used || 0));
        setConnectionStatus('online');

        // Mise √† jour tokens en temps r√©el
        if (data.tokens_used) {
          updateTokenUsage(data.tokens_used);
        }

        // G√©rer progression √©tapes
        if (mode === 'step_by_step' && data.next_step?.next) {
          setCurrentStep(data.next_step.next);
        }

        // Synth√®se vocale si mode audio activ√©
        if (isAudioMode && data.response) {
          setTimeout(() => speakResponse(data.response), 500);
        }

        // Notification stats parent
        if (onStatsUpdate && student?.id) {
          try {
            onStatsUpdate(student.id);
          } catch (statsError) {
            console.warn('‚ö†Ô∏è Erreur mise √† jour stats:', statsError.message);
          }
        }

        console.log(`‚úÖ IA a r√©pondu avec succ√®s. Document utilis√©: "${aiMessage.documentUsed}" (${aiMessage.contextLength} chars)`);

      } else {
        throw new Error(data.error || 'Erreur communication IA');
      }
    } catch (error) {
      console.error('‚ùå Erreur chat compl√®te:', {
        error_name: error.name,
        error_message: error.message,
        student_id: student?.id,
        api_url: apiUrl,
        has_document: !!(activeDocument?.texte_extrait || documentContext)
      });
      
      setConnectionStatus('error');
      
      // Message d'erreur contextuel intelligent
      let errorContent;
      
      if (error.message.includes('404')) {
        errorContent = `${prenomEleve}, la route de chat √âtudIA est introuvable ! üîç

üîß **Probl√®me**: Route /api/chat non trouv√©e sur le serveur

üí° **Solutions imm√©diates**:
‚Ä¢ V√©rifie que le serveur Render est d√©marr√©
‚Ä¢ Recharge la page (F5)
‚Ä¢ V√©rifie l'URL du serveur dans la console

ü§ñ **URL actuelle**: ${apiUrl}/api/chat`;

      } else if (error.message.includes('Failed to fetch') || error.message.includes('network')) {
        errorContent = `${prenomEleve}, probl√®me de connexion r√©seau ! üåê

üîß **Probl√®me**: Impossible de joindre le serveur √âtudIA

üí° **Solutions**:
‚Ä¢ V√©rifie ta connexion internet
‚Ä¢ Le serveur Render est peut-√™tre en train de d√©marrer (30s)
‚Ä¢ R√©essaie dans quelques instants

ü§ñ √âtudIA sera bient√¥t de retour !`;

      } else {
        errorContent = `D√©sol√© ${prenomEleve}, probl√®me technique ! üòÖ

üîß **Erreur**: ${error.message.substring(0, 100)}

${activeDocument ? 
  `J'ai bien ton document "${activeDocument.nom_original}" mais je n'arrive pas √† le traiter.` : 
  'Tu n\'as pas encore upload√© de document.'}

üí° **Solutions**:
${!activeDocument ? '‚Ä¢ Upload d\'abord un document\n' : ''}‚Ä¢ Recharge la page (F5)  
‚Ä¢ R√©essaie dans 30 secondes
‚Ä¢ V√©rifie ta connexion

ü§ñ √âtudIA sera bient√¥t de retour !`;
      }
      
      const errorMessage = {
        id: Date.now() + 1,
        type: 'ai',
        content: errorContent,
        timestamp: new Date().toISOString(),
        tokens: 0,
        isError: true,
        hasContext: !!(activeDocument?.texte_extrait || documentContext),
        errorType: error.name,
        canRetry: true
      };
      
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  // üéØ BOUTON 1: MODE √âTAPE PAR √âTAPE 
  const activateStepByStepMode = () => {
    setChatMode('step_by_step');
    setCurrentStep(1);
    setTotalSteps(4);
    
    const modeMessage = `üîÅ Mode "√âtape par √âtape" activ√© !

${prenomEleve}, je vais te guider progressivement √† travers chaque √©tape de r√©solution.

üìä Format strict : "üìä √âtape X/4"
üéØ Une seule question √† la fois
‚úÖ Validation de ta compr√©hension

Pose ta question et nous proc√©derons √©tape par √©tape ! üöÄ`;

    const systemMessage = {
      id: Date.now(),
      type: 'system',
      content: modeMessage,
      timestamp: new Date().toISOString(),
      mode: 'step_by_step'
    };

    setMessages(prev => [...prev, systemMessage]);
  };

  // üéØ BOUTON 2: MODE SOLUTION DIRECTE
  const activateDirectSolutionMode = () => {
    setChatMode('direct_solution');
    
    const confirmMessage = `‚úÖ Mode "Solution Directe" activ√© !

${prenomEleve}, je vais analyser ton document et te donner toutes les solutions compl√®tes.

üéØ Toutes les r√©ponses finales
üìù Solutions d√©taill√©es et structur√©es
üí° Explications claires pour chaque calcul
‚ö° R√©sultats imm√©diats

Quel exercice veux-tu que je r√©solve compl√®tement ?`;

    const systemMessage = {
      id: Date.now(),
      type: 'system', 
      content: confirmMessage,
      timestamp: new Date().toISOString(),
      mode: 'direct_solution'
    };

    setMessages(prev => [...prev, systemMessage]);
  };

  // üé§ MODE AUDIO AM√âLIOR√â
  const toggleAudioMode = () => {
    setIsAudioMode(!isAudioMode);
    
    if (!isAudioMode) {
      const audioMessage = {
        id: Date.now(),
        type: 'system',
        content: `üé§ Mode Audio activ√© !

${prenomEleve}, tu peux maintenant :
üéôÔ∏è Parler √† √âtudIA (clic sur le bouton micro)
üîä Entendre mes r√©ponses vocalement
‚úçÔ∏è Continuer √† √©crire normalement

Clique sur üéôÔ∏è pour commencer √† parler !`,
        timestamp: new Date().toISOString(),
        mode: 'audio'
      };
      setMessages(prev => [...prev, audioMessage]);
      
      setTimeout(() => speakResponse(`Mode audio activ√© ! ${prenomEleve}, tu peux maintenant me parler !`), 1000);
    } else {
      speechSynthesis.cancel();
      const audioOffMessage = {
        id: Date.now(),
        type: 'system',
        content: `üîá Mode Audio d√©sactiv√© !

${prenomEleve}, retour au mode texte uniquement.`,
        timestamp: new Date().toISOString(),
        mode: 'normal'
      };
      setMessages(prev => [...prev, audioOffMessage]);
    }
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const handleSuggestionClick = (suggestion) => {
    handleSendMessage(suggestion);
  };

  // Retour mode normal
  const resetToNormalMode = () => {
    setChatMode('normal');
    setCurrentStep(1);
    
    const resetMessage = {
      id: Date.now(),
      type: 'system',
      content: `‚Ü©Ô∏è Retour au mode normal !

${prenomEleve}, nous reprenons la conversation √©quilibr√©e. Tu peux √† nouveau choisir tes modes d'apprentissage !`,
      timestamp: new Date().toISOString(),
      mode: 'normal'
    };

    setMessages(prev => [...prev, resetMessage]);
  };

  const formatMessage = (content) => {
    return content
      .split('\n')
      .map((line, index) => (
        <React.Fragment key={index}>
          {line}
          {index < content.split('\n').length - 1 && <br />}
        </React.Fragment>
      ));
  };

  const formatTime = (timestamp) => {
    return new Date(timestamp).toLocaleTimeString('fr-FR', {
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  // Obtenir couleur selon le mode
  const getModeColor = (mode) => {
    switch (mode) {
      case 'step_by_step': return '#FF8C00';
      case 'direct_solution': return '#32CD32';
      case 'audio': return '#F59E0B';
      default: return '#6366F1';
    }
  };

  return (
    <div className={`tab-content chat-tab ${isDarkMode ? 'dark-mode' : ''}`}>
      <div className="content-header">
        <h2>ü§ñ Chat R√©volutionnaire avec √âtudIA</h2>
        <p>Votre tuteur IA personnel avec m√©moire et modes d'apprentissage adaptatifs !</p>
        
        {/* üîß HEADER AM√âLIOR√â AVEC COMPTEUR TOKENS CORRIG√â */}
        <div className="student-profile-header">
          <div className="student-info">
            <span className="student-name">üë§ {prenomEleve} ‚Ä¢ üéì {classeEleve}</span>
            {learningProfile && (
              <span className="learning-style">
                üß† Style: {learningProfile.style || 'adaptatif'}
              </span>
            )}
            {(documentContext || allDocuments.length > 0) && (
              <span className="document-badge">
                üìÑ {allDocuments.length > 0 ? 
                  `${allDocuments.length} document(s)` : 
                  'Document analys√©'}
              </span>
            )}
          </div>
          
          <div className="status-section">
            <div className="current-mode" style={{ color: getModeColor(chatMode) }}>
              <span className="mode-indicator">
                {chatMode === 'step_by_step' ? 'üîÅ √âtape par √âtape' :
                 chatMode === 'direct_solution' ? '‚úÖ Solution Directe' :
                 chatMode === 'audio' ? 'üé§ Audio' : 'üí¨ Normal'}
              </span>
              {chatMode === 'step_by_step' && (
                <span className="step-counter">üìä √âtape {currentStep}/{totalSteps}</span>
              )}
            </div>
            
            {/* üîß CORRECTION 10: AFFICHAGE TOKENS CORRIG√â */}
            <div className="tokens-display">
              <div className="tokens-bar">
                <div 
                  className="tokens-fill" 
                  style={{ 
                    width: `${Math.min(100, (tokenUsage.used_today / 95000) * 100)}%`,
                    backgroundColor: tokenUsage.used_today > 85000 ? '#EF4444' : 
                                    tokenUsage.used_today > 50000 ? '#F59E0B' : '#32CD32'
                  }}
                ></div>
              </div>
              <span className="tokens-text">
                Tokens: {tokenUsage.used_today.toLocaleString('fr-FR')}/{(95000).toLocaleString('fr-FR')}
              </span>
              <div className="connection-status">
                <div className={`status-dot ${connectionStatus}`}></div>
                <span>{connectionStatus === 'online' ? 'En ligne' : 
                       connectionStatus === 'offline' ? 'Hors ligne' : 'Connexion...'}</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div className="chat-container">
        {/* üîß HEADER CONTR√îLES AM√âLIOR√â */}
        <div className="chat-header revolutionary">
          <div className="chat-title">
            <span className="title-icon">üí¨</span>
            <span className="title-text">√âtudIA - Tuteur IA R√©volutionnaire</span>
          </div>
          
          <div className="chat-controls">
            <button 
              onClick={() => setIsDarkMode(!isDarkMode)}
              className={`control-button ${isDarkMode ? 'active' : ''}`}
              title="Mode sombre"
            >
              {isDarkMode ? '‚òÄÔ∏è' : 'üåô'}
            </button>
            
            <button
              onClick={toggleAudioMode}
              className={`control-button audio-btn ${isAudioMode ? 'active' : ''}`}
              title="Mode audio"
            >
              üé§
            </button>
          </div>
        </div>

        {/* üöÄ BOUTONS R√âVOLUTIONNAIRES CORRIG√âS */}
        {chatMode === 'normal' && (
          <div className="revolutionary-buttons">
            <div className="mode-buttons-header">
              <h3>üéØ Choisis ton mode d'apprentissage, {prenomEleve} !</h3>
            </div>
            
            <div className="mode-buttons-grid">
              <button
                onClick={() => setChatMode('normal')}
                className="mode-button normal active"
                disabled={isLoading}
              >
                <div className="mode-icon">üí¨</div>
                <div className="mode-content">
                  <div className="mode-title">Mode Normal</div>
                  <div className="mode-description">
                    Conversation √©quilibr√©e avec √âtudIA - Ni trop guid√©, ni trop direct
                  </div>
                  <div className="mode-benefit">‚öñÔ∏è √âquilibre parfait</div>
                </div>
              </button>

              <button
                onClick={activateStepByStepMode}
                className="mode-button step-by-step"
                disabled={isLoading}
              >
                <div className="mode-icon">üîÅ</div>
                <div className="mode-content">
                  <div className="mode-title">Explication √âtape par √âtape</div>
                  <div className="mode-description">
                    Je te guide progressivement √† travers chaque √©tape de r√©solution
                  </div>
                  <div className="mode-benefit">‚ú® Compr√©hension garantie</div>
                </div>
              </button>

              <button
                onClick={activateDirectSolutionMode}
                className="mode-button direct-solution"
                disabled={isLoading}
              >
                <div className="mode-icon">‚úÖ</div>
                <div className="mode-content">
                  <div className="mode-title">Solution Finale</div>
                  <div className="mode-description">
                    Je donne directement toutes les solutions compl√®tes de tes exercices
                  </div>
                  <div className="mode-benefit">‚ö° R√©sultats imm√©diats</div>
                </div>
              </button>
            </div>
          </div>
        )}

        {/* Bouton retour au mode normal */}
        {chatMode !== 'normal' && (
          <div className="mode-reset">
            <button onClick={resetToNormalMode} className="reset-button">
              ‚Ü©Ô∏è Retour au mode normal
            </button>
          </div>
        )}

        {/* üîß ZONE MESSAGES AM√âLIOR√âE */}
        <div className="chat-messages enhanced">
          {messages.map((message) => (
            <div
              key={message.id}
              className={`message-bubble ${message.type} ${message.mode ? `mode-${message.mode}` : ''}`}
            >
              <div className="message-content">
                {formatMessage(message.content)}
              </div>
              <div className="message-meta">
                <div className="message-time">
                  {formatTime(message.timestamp)}
                </div>
                <div className="message-info">
                  {message.isWelcome && (
                    <span className="message-tag welcome">üéâ Accueil</span>
                  )}
                  {message.hasContext && (
                    <span className="message-tag context">üìÑ Doc</span>
                  )}
                  {message.mode && message.mode !== 'normal' && (
                    <span className="message-tag mode" style={{ backgroundColor: getModeColor(message.mode) }}>
                      {message.mode === 'step_by_step' ? 'üîÅ √âtapes' :
                       message.mode === 'direct_solution' ? '‚úÖ Solution' :
                       message.mode === 'audio' ? 'üé§ Audio' : message.mode}
                    </span>
                  )}
                  {message.tokens > 0 && (
                    <span className="message-tokens">
                      {message.tokens} tokens
                    </span>
                  )}
                  {message.isError && (
                    <span className="message-tag error">‚ö†Ô∏è Erreur</span>
                  )}
                  {message.isOffline && (
                    <span className="message-tag offline">üì∂ Hors ligne</span>
                  )}
                </div>
              </div>
            </div>
          ))}

          {/* üîß INDICATEUR CHARGEMENT AM√âLIOR√â */}
          {isLoading && (
            <div className="message-bubble ai loading enhanced">
              <div className="message-content">
                <div className="ai-thinking">
                  <div className="thinking-animation">
                    <div className="dot"></div>
                    <div className="dot"></div>
                    <div className="dot"></div>
                  </div>
                  <div className="thinking-text">
                    <span className="main-text">ü¶ô √âtudIA analyse ta question...</span>
                    {chatMode === 'step_by_step' && (
                      <div className="step-info">üìä Pr√©paration √©tape {currentStep}/{totalSteps}</div>
                    )}
                    {chatMode === 'direct_solution' && (
                      <div className="step-info">‚úÖ R√©solution compl√®te en cours...</div>
                    )}
                    {isAudioMode && (
                      <div className="step-info">üé§ R√©ponse vocale activ√©e</div>
                    )}
                  </div>
                </div>
              </div>
            </div>
          )}

          <div ref={messagesEndRef} />
        </div>

        {/* Section d'entr√©e */}
        <div className="chat-input-container">
          {/* Suggestions intelligentes */}
          {messages.length <= 2 && !isLoading && (
            <div className="suggestions-container">
              <div className="suggestions-title">
                üí° Questions sugg√©r√©es pour {prenomEleve} :
              </div>
              <div className="suggestions-grid">
                {getSuggestions().slice(0, 4).map((suggestion, index) => (
                  <button
                    key={index}
                    className="suggestion-button"
                    onClick={() => handleSuggestionClick(suggestion)}
                    disabled={isLoading}
                  >
                    {suggestion}
                  </button>
                ))}
              </div>
            </div>
          )}

          {/* üîß ZONE SAISIE DARK MODE CORRIG√âE */}
          <div className="chat-input-wrapper revolutionary enhanced">
            <div className="input-container">
              <textarea
                ref={inputRef}
                className="chat-input enhanced"
                value={inputMessage}
                onChange={(e) => setInputMessage(e.target.value)}
                onKeyPress={handleKeyPress}
                placeholder={
                  isRecording ? `üé§ √âcoute en cours... Parlez maintenant !` :
                  chatMode === 'step_by_step' ? `${prenomEleve}, pose ta question pour l'√©tape ${currentStep}...` :
                  chatMode === 'direct_solution' ? `${prenomEleve}, quel exercice r√©soudre directement ?` :
                  isAudioMode ? `${prenomEleve}, parle (üéôÔ∏è) ou √©cris √† √âtudIA...` :
                  `${prenomEleve}, pose une question √† ton tuteur IA...`
                }
                disabled={isLoading || isRecording}
                rows={1}
                style={{
                  borderColor: isRecording ? '#F59E0B' : getModeColor(chatMode),
                  backgroundColor: isRecording ? 'rgba(245, 158, 11, 0.1)' : 'white'
                }}
              />
              
              <div className="input-buttons">
                {isAudioMode && (
                  <button
                    className={`voice-button ${isRecording ? 'recording' : ''}`}
                    onClick={startVoiceRecognition}
                    disabled={isLoading || isRecording}
                    title={isRecording ? "√âcoute en cours..." : "Parler √† √âtudIA"}
                  >
                    {isRecording ? 'üî¥' : 'üéôÔ∏è'}
                  </button>
                )}
                
                <button
                  className="send-button enhanced"
                  onClick={() => handleSendMessage()}
                  disabled={!inputMessage.trim() || isLoading || isRecording}
                  style={{ backgroundColor: getModeColor(chatMode) }}
                >
                  <span className="send-icon">
                    {isLoading ? '‚è≥' : 
                     isRecording ? 'üé§' :
                     chatMode === 'step_by_step' ? 'üìä' :
                     chatMode === 'direct_solution' ? '‚úÖ' : 'üöÄ'}
                  </span>
                </button>
              </div>
            </div>

            <div className="input-hints enhanced">
              {isRecording && (
                <span className="hint recording">üé§ Parlez maintenant ! √âtudIA vous √©coute...</span>
              )}
              {!isRecording && chatMode === 'normal' && (
                <span className="hint normal">üí° Conseil : Choisis un mode d'apprentissage pour une exp√©rience optimis√©e</span>
              )}
              {!isRecording && chatMode === 'step_by_step' && (
                <span className="hint step">üìä Mode √âtape par √âtape : Je te guide progressivement vers la solution</span>
              )}
              {!isRecording && chatMode === 'direct_solution' && (
                <span className="hint direct">‚úÖ Mode Solution Directe : Je r√©sous compl√®tement tes exercices</span>
              )}
              {!isRecording && isAudioMode && chatMode === 'normal' && (
                <span className="hint audio">üé§ Mode Audio actif : Parle (üéôÔ∏è) ou √©cris √† √âtudIA - R√©ponses vocales automatiques</span>
              )}
              {tokenUsage.used_today > 85000 && (
                <span className="hint warning">‚ö†Ô∏è Attention : Limite tokens bient√¥t atteinte ({tokenUsage.remaining.toLocaleString('fr-FR')} restants)</span>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Informations sur les fonctionnalit√©s */}
      {messages.length <= 2 && (
        <div className="features-showcase">
          <h3>üöÄ Fonctionnalit√©s R√©volutionnaires d'√âtudIA</h3>
          
          <div className="features-grid revolutionary">
            <div className="feature-card memory">
              <span className="feature-icon">üß†</span>
              <h4>M√©moire IA Personnalis√©e</h4>
              <p>√âtudIA m√©morise ton style d'apprentissage et s'adapte automatiquement</p>
              {learningProfile && (
                <div className="profile-info">
                  Style d√©tect√©: <strong>{learningProfile.style}</strong>
                </div>
              )}
            </div>
            
            <div className="feature-card modes">
              <span className="feature-icon">üéØ</span>
              <h4>Modes d'Apprentissage</h4>
              <p>Choisis entre guidage √©tape par √©tape ou solutions directes</p>
              <div className="mode-badges">
                <span className="mode-badge step">üîÅ √âtape par √âtape</span>
                <span className="mode-badge direct">‚úÖ Solution Directe</span>
              </div>
            </div>
                        
            <div className="feature-card audio">
              <span className="feature-icon">üé§</span>
              <h4>Mode Audio Fonctionnel</h4>
              <p>Parle √† √âtudIA avec reconnaissance vocale et √©coute ses r√©ponses</p>
              <div className="audio-status">
                {isAudioMode ? (
                  <span className="status-active">üü¢ Activ√© - Clic üéôÔ∏è pour parler</span>
                ) : (
                  <span className="status-available">‚ö™ Disponible - Clic üé§ pour activer</span>
                )}
              </div>
            </div>
          </div>

          <div className="personal-stats">
            <h4>üìä Tes Statistiques, {prenomEleve}</h4>
            <div className="stats-grid">
              <div className="stat-item">
                <span className="stat-number">{conversationCount}</span>
                <span className="stat-label">Conversations</span>
              </div>
              <div className="stat-item">
                <span className="stat-number">{tokenUsage.used_today.toLocaleString('fr-FR')}</span>
                <span className="stat-label">Tokens utilis√©s</span>
              </div>
              <div className="stat-item">
                <span className="stat-number">
                  {allDocuments?.length || (documentContext ? '1' : '0')}
                </span>
                <span className="stat-label">Documents analys√©s</span>
              </div>
              <div className="stat-item">
                <span className="stat-number">
                  {learningProfile?.level || Math.min(5, Math.ceil(conversationCount / 10))}
                </span>
                <span className="stat-label">Niveau IA</span>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* CSS STYLES COMPLETS */}
      <style jsx>{`
        /* Tous les styles CSS pr√©c√©dents restent identiques */
        /* ... [tous les styles du code pr√©c√©dent] ... */
      `}</style>
    </div>
  );
};

export default ChatIA;
